#+title: Emacs Config
#+PROPERTY: header-args :tangle yes
* Initial Configuration
** Lexical Bindings
#+begin_src elisp
;; -*- lexical-binding: t; -*-
#+end_src

This has to be the first line of the file.

** Basic Configs
We'll set some basic configs here - relative line numbers, silencing sound effects and some basic setup for autocomplete:
#+begin_src elisp
  (setq display-line-numbers 'relative
        ring-bell-function 'ignore
        inhibit-startup-screen t

        read-file-name-completion-ignore-case t
        read-buffer-completion-ignore-case t
        completion-ignore-case t
        completion-styles '(basic substring partial-completion flex)
        warning-suppress-log-types '((files missing-lexbind-cookie)))
#+end_src


* File System Setup
** Repository Location
First, we have to set where the Git repository is located.

If it's hosted locally, put the path to the repository here.

If it's just pulled straight from the flake, leave it as nil.
#+begin_src elisp
(setq emacs-flake-dir "~/projects/emacs-flake")
#+end_src

** Customization File
Our customisations are stored in =\~/.emacs.d/custom.el=.
To use them properly, every time Emacs launches, we check between our local customisations file and the one stored in the home file.

If the locally stored file is newer than the one in the git repository, copy the new one to git.
Otherwise, if the customizations file doesn't exist locally, copy it from git.

  #+begin_src elisp
    (setq custom-file "~/.emacs.d/custom.el")

    (let ((dir (if emacs-flake-dir emacs-flake-dir "./")))
      (if (or
           (file-newer-than-file-p (expand-file-name "custom.el" dir)
          			       "~/.emacs.d/custom.el")
           (not (file-exists-p "~/.emacs.d/custom.el")))
          (copy-file (expand-file-name "custom.el" dir) "~/.emacs.d/custom.el" t)
        (when (not (file-exists-p "~/.emacs.d/custom.el"))
          (copy-file "~/.emacs.d/custom.el" (expand-file-name "custom.el" dir) t))))
    (load "~/.emacs.d/custom.el")
#+end_src

* Appearance
** Theme
Set the theme to Gruvbox.
#+begin_src elisp
(load-theme 'gruvbox t)
#+end_src

** Fonts
Set the default font to Maple Mono.
#+begin_src elisp
  (set-face-attribute 'default nil :font "Maple Mono" :height 160)
#+end_src

** Line Wrapping
Disable line wrapping, please! :)
#+begin_src elisp
  (toggle-truncate-lines 1)
#+end_src

* Modes
We set all of the basic modes, of course.
#+begin_src elisp
  ;;(require 'evil)
  ;;(require 'electric)

  (evil-mode 1)
  (vertico-mode 1)
  (ivy-mode 1)
  (ivy-prescient-mode 1)
  (org-roam-db-autosync-mode 1)
  (which-key-mode 1)
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  (indent-tabs-mode 0)
#+end_src

** Evil
*** Undo System
Set the undo system for =evil-mode=.
#+begin_src elisp
  (evil-set-undo-system 'undo-redo)
#+end_src

** Org
Next is basic setup for org mode:
#+begin_src elisp
  (setq org-roam-directory (file-truename "~/org")
        org-id-locations-file (expand-file-name ".org-id-locations" org-roam-directory)
        org-roam-db-location (expand-file-name "org-roam.db" org-roam-directory))
#+end_src

*** Org Latex Previews
Set the process for generating previews:
#+begin_src elisp
  (setq org-preview-latex-default-process 'dvipng)
#+end_src

* Hooks
** Org Mode
Enable additional minor modes for =org-mode=.
#+begin_src elisp
  (defun org-mode-enable ()
    (org-fragtog-mode 1)
    (org-indent-mode 1)
    (org-roam-db-autosync-mode)
    )
  (add-hook 'org-mode-hook 'org-mode-enable)
#+end_src

** Prog Mode
This hook enables line numbers, formatting and autocomplete in all programming buffers.
#+begin_src elisp
  (defun prog-mode-enable ()
    (display-line-numbers-mode 1)
    (format-all-mode)
    (company-mode))
  (add-hook 'prog-mode-hook 'prog-mode-enable)
#+end_src
** LSP Auto-Enable
We want LSP mode to be enabled for every mode that it supports, but /not/ enabled for modes that it doesn't support.

To do that, I've written a macro that sets multiple hooks to activate =lsp-mode=.

#+begin_src elisp
  ;; input
  ;; (lsp-attach-hook 'java-mode-hook 'python-mode-hook)
  ;;
  ;; output
  ;; (add-hook 'java-mode-hook 'lsp-mode)
  ;; (add-hook 'python-mode-hook 'lsp-mode)

  (defmacro lsp-attach-hook (&rest args)
    `(progn ,@(mapcar #'(lambda (a) `(add-hook ,a 'lsp-mode)) args) t))
  (lsp-attach-hook 'java-mode-hook 'lsp-mode-hook)
#+end_src

** Text Mode
Enable =visual-line-mode= for all text buffers.
#+begin_src elisp
(add-hook 'text-mode-hook 'visual-line-mode)
#+end_src
* Additional Functions
** Hide Drawers
This hides the drawers under every heading in Org Mode.
These are used for the =SPC m h= command in the [[*Org Mode Map][org-mode map]].
#+begin_src elisp
(defun org-cycle-hide-drawers (state)
  "Re-hide all drawers after a visibility state change."
  (when (and (derived-mode-p 'org-mode)
	     (not (memq state '(overview folded contents))))
    (save-excursion
      (let* ((globalp (memq state '(contents all)))
	     (beg (if globalp
		      (point-min)
		    (point)))
	     (end (if globalp
		      (point-max)
		    (if (eq state 'children)
			(save-excursion
			  (outline-next-heading)
			  (point))
		      (org-end-of-subtree t)))))
	(goto-char beg)
	(while (re-search-forward org-drawer-regexp end t)
	  (save-excursion
	    (beginning-of-line 1)
	    (when (looking-at org-drawer-regexp)
	      (let* ((start (1- (match-beginning 0)))
		     (limit
		      (save-excursion
			(outline-next-heading)
			(point)))
		     (msg (format
			   (concat
			    "org-cycle-hide-drawers:  "
			    "`:END:`"
			    " line missing at position %s")
			   (1+ start))))
		(if (re-search-forward "^[ \t]*:END:" limit t)
		    (outline-flag-region start (line-end-position) t)
		                    (user-error msg))))))))))

#+end_src

** Window Controls
These functions are used for the =SPC v= and =SPC h= commands in the [[*Window Map][Window Map]].

#+begin_src elisp
(defun +evil/window-split-and-follow()
  "Split current window horizontally, then focus on new window.
   If `evil-split-window-below` is non-nil, the new window isn't focused."
  (interactive)
  (let ((evil-split-window-below (not evil-split-window-below)))
    (call-interactively #'evil-window-split)))

(defun +evil/window-vsplit-and-follow()
  "Split current window vertically, then focus on new window.
   If `evil-split-window-below` is non-nil, the new window isn't focused."
  (interactive)
  (let ((evil-vsplit-window-right (not evil-vsplit-window-right)))
    (call-interactively #'evil-window-vsplit)))

#+end_src



** Org ID Reload All
This function reloads all org IDs - good for resyncing the database.
#+begin_src elisp
(defun org-id-reload-all ()
    (interactive)
    (org-id-update-id-locations)
    (org-roam-update-org-id-locations)
    (org-roam-db-sync))
#+end_src

* Keybinds
** Maps
*** Org Mode Map
This lets us use =TAB= to show/hide contents of headers in Org mode.
#+begin_src elisp
  (evil-define-key 'normal org-mode-map (kbd "<TAB>") 'org-cycle)
#+end_src
** Global Binds
*** Navigation
**** Avy
We'll set a few global navigation keybinds using *Avy*.
These allow us to move around files much quicker.

#+begin_src elisp
(evil-define-key '(list normal motion visual) global-map (kbd "-") 'avy-goto-char)
(evil-define-key '(list normal motion visual) global-map (kbd "_") 'avy-goto-line)
#+end_src

**** Marks
This keybind takes you to the most recent mark:
#+begin_src elisp
(evil-define-key 'normal global-map (kbd "=") 'pop-global-mark)
#+end_src

**** Ace Window
This sets a keybind accessible everywhere to use Ace Window for navigating between windows.
#+begin_src elisp
(keymap-global-set "M-o" 'ace-window)
#+end_src

**** Electric Buffer List
This makes the buffer list easily accessible:
#+begin_src elisp
  (keymap-global-set "C-x C-<up>" 'electric-buffer-list)
  (keymap-global-set "C-x C-b" 'electric-buffer-list)
#+end_src

and we also need a keybind for making sure selection works - however, I've had a few issues in getting this to work.

This function throws an error since ='Electric-buffer-menu-select= doesn't exist at the time the code is run.

#+begin_src elisp :tangle yes
  (setq electric-buffer-menu-mode-map (make-keymap))
  (define-key electric-buffer-menu-mode-map (kbd "o") 'Electric-buffer-menu-select)
#+end_src

The best option seems to be using =use-package= like so:
  #+begin_src elisp
  #+end_src

*** Typing
**** Surround
This lets us use =S= to surround text while in Visual mode.
#+begin_src elisp
(evil-define-key 'visual global-map "S" 'surround-insert)
#+end_src

*** Leader Maps
**** Global Leader Maps
***** Window Map
This map is for moving between windows on the screen.
#+begin_src elisp
  (defvar window-map (define-keymap 
  		     "h" #'evil-window-left
  		     "j" #'evil-window-down
  		     "k" #'evil-window-up
  		     "l" #'evil-window-right
                       "H" #'window-move-left
  		     "J" #'window-move-down
  		     "K" #'window-move-up
  		     "L" #'window-move-right
  		     "v" #'+evil/window-vsplit-and-follow
  		     "n" #'+evil/window-split-and-follow
  		     "r" #'redraw-display
  		     ))
#+end_src

***** Config Map
This map is for easily accessing config files.

#+begin_src elisp
  (defvar config-map (define-keymap 
  		     "r" (lambda () (interactive) (load "~/nixos/emacs/init.el"))
  		     "h" (lambda () (interactive) (find-file "~/org/contents.org"))
  		     "c" (lambda () (interactive) (find-file "~/projects/emacs-flake/readme.org"))
  		     "k" (lambda () (interactive) (find-file "~/projects/emacs-flake/readme.org"))
  		     "d" (lambda () (interactive) (dired "./"))
  		     ))
  #+end_src

***** View Map
This map is for managing viewmodes easily.
#+begin_src elisp
  (defvar view-map (define-keymap 
  		   "v" #'org-toggle-narrow-to-subtree
  		   "h" (lambda() (interactive) (org-cycle-hide-drawers 'all))
  		   "l" #'lsp-describe-at-point
  		   ))
#+end_src

***** Buffer Map
This map is for managing and navigating buffers.
#+begin_src elisp
(defvar buffer-map (define-keymap :full t
		     "p" #'previous-buffer
		     "n" #'next-buffer
		     "b" #'buffer-menu
		     ))
#+end_src

***** Customisation Map
This map is for customising variables, faces, etc.
#+begin_src elisp
(defvar customize-map (define-keymap
		        "c" #'customize-browse
			"f" #'list-faces-display
			"v" #'customize-variable
			"g" #'customize-group
			))
#+end_src

***** Project Map
This map is for working with =lsp-mode=, =projectile= and =treemacs=.
#+begin_src elisp
  (defvar project-map (define-keymap
  		      "t" #'treemacs
  		      "e" (lambda () (interactive) (lsp-treemacs-errors-list))
  		      "x" #'projectile-compile-project
  		      "p" (lambda () (interactive)
  			    (projectile-switch-project))
  		      "l" #'lsp
  		      "v" #'vterm
  		      "s" (lambda () (interactive)
  			    (lsp-treemacs-errors-list)
  			    (treemacs)
  			    (lsp))
  		      ))
#+end_src

***** Leader Map
This map is the most important one - this map appears whenever you press Space while in Evil Mode, and defines every map that you can move to.
#+begin_src elisp
(defvar leader-map (define-keymap
  "." #'find-file
  "w" window-map
  "d" config-map
  "v" view-map
  "b" buffer-map
  "c" customize-map
  "h" help-map
  "/" #'avy-goto-char-2
  ))
#+end_src

**** Mode Specific Leader Maps
***** Setup
*I LOVE MACROS!!!!!*

This macro constructs a way to define keys for specific maps:
#+begin_src elisp
(defmacro set-local-leader-map (source-map key &rest args)
  `(progn
     (evil-define-key 'normal ,source-map (kbd "<SPC>")
       (let ((map (make-sparse-keymap)))
	 (set-keymap-parent map leader-map)
	 (define-key map (kbd ,key) ,(append
				     (list 'define-keymap)
				     args))

	 map))))
#+end_src

Specifically, it constructs:
#+begin_src elisp :tangle no
  (set-local-leader-map test-mode-map "m" "a" #'test-function)
#+end_src
into:
#+begin_src elisp :tangle no
  (progn
    (evil-define-key 'normal test-mode-map (kbd "<SPC>")
      (let ((map (make-sparse-keymap)))
        (set-keymap-parent map leader-map)
        (define-key map (kbd "m") (define-keymap
  				  "a" #'test-function))
        map)))
#+end_src

My favourite trick in there is using =append= to combine two lists - one list containing =define-keymap=, and the other containing the arguments, creating one list - =(define-keymap "a" #'test-function)=.


***** Org Mode Leader Map
Set keybinds for org mode - primarily just commands I use a lot.

#+begin_src elisp
(set-local-leader-map org-mode-map "m"
			"." #'consult-org-heading
			"l i" #'org-id-get-create
			"i" #'org-roam-node-insert
			"f" #'org-roam-node-find
			"r" #'org-id-reload-all
			"b" #'org-mark-ring-goto
			)
#+end_src

*** Leader Key
This makes the Leader key (=<SPC>=) activate the [[*Leader Map][Leader Map]].
#+begin_src elisp
(evil-define-key 'normal global-map (kbd "<SPC>") leader-map)
#+end_src
